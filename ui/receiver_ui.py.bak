import customtkinter as ctk
from tkinter import filedialog, messagebox
import tkinter as tk
import threading
import queue
import os
from network.client import HTTPClient


# â”€â”€â”€ Color Palette (Windows 11 inspired) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
C = {
    "bg":           "#1e1e2e",
    "card":         "#2b2b3d",
    "sidebar":      "#252536",
    "hover":        "#35354a",
    "accent":       "#0078d4",
    "accent_hover": "#1a8cff",
    "text":         "#e4e4e8",
    "text2":        "#9090a0",
    "text_dim":     "#6c6c80",
    "success":      "#2ecc71",
    "danger":       "#e74c3c",
    "border":       "#3a3a50",
    "white":        "#ffffff",
    "input_bg":     "#333348",
    "row_alt":      "#2f2f42",
    "row_hover":    "#383850",
    "selected":     "#1a3a5c",
}

FILE_ICONS = {
    ".txt": "ğŸ“„", ".md": "ğŸ“„", ".log": "ğŸ“„",
    ".py": "ğŸ", ".js": "ğŸ“œ", ".ts": "ğŸ“œ", ".java": "â˜•", ".c": "âš™ï¸", ".cpp": "âš™ï¸",
    ".html": "ğŸŒ", ".css": "ğŸ¨", ".json": "ğŸ“‹", ".xml": "ğŸ“‹", ".yaml": "ğŸ“‹", ".yml": "ğŸ“‹",
    ".jpg": "ğŸ–¼ï¸", ".jpeg": "ğŸ–¼ï¸", ".png": "ğŸ–¼ï¸", ".gif": "ğŸ–¼ï¸", ".svg": "ğŸ–¼ï¸", ".bmp": "ğŸ–¼ï¸",
    ".mp4": "ğŸ¬", ".avi": "ğŸ¬", ".mkv": "ğŸ¬", ".mov": "ğŸ¬",
    ".mp3": "ğŸµ", ".wav": "ğŸµ", ".flac": "ğŸµ", ".ogg": "ğŸµ",
    ".zip": "ğŸ“¦", ".tar": "ğŸ“¦", ".gz": "ğŸ“¦", ".rar": "ğŸ“¦", ".7z": "ğŸ“¦",
    ".pdf": "ğŸ“•", ".doc": "ğŸ“˜", ".docx": "ğŸ“˜", ".xls": "ğŸ“Š", ".xlsx": "ğŸ“Š",
    ".exe": "âš¡", ".sh": "âš¡", ".bat": "âš¡",
}


def _icon_for(name, ftype):
    if ftype == "folder":
        return "ğŸ“"
    ext = os.path.splitext(name)[1].lower()
    return FILE_ICONS.get(ext, "ğŸ“„")


def _human_size(size):
    if size == 0:
        return "â€”"
    for unit in ['B', 'KB', 'MB', 'GB']:
        if size < 1024:
            return f"{size:.1f} {unit}" if unit != 'B' else f"{size} B"
        size /= 1024
    return f"{size:.1f} TB"


class FileRow(ctk.CTkFrame):
    """A single row in the file browser that represents a file or folder."""
    def __init__(self, master, entry, depth=0, on_toggle=None, **kwargs):
        super().__init__(master, fg_color="transparent", corner_radius=0, height=36, **kwargs)
        self.pack_propagate(False)
        self.entry = entry
        self.on_toggle = on_toggle
        self.selected = ctk.BooleanVar(value=False)

        is_file = entry["type"] == "file"
        is_folder_unit = entry.get("is_folder_unit", False)
        icon = _icon_for(entry["name"], entry["type"])
        
        # Display name (for folders with file count)
        display_name = entry.get("display_name", entry["name"])
        size_text = _human_size(entry["size"]) if entry["size"] > 0 else ""

        # Always show checkbox for downloadable items (files and folder units)
        if is_file or is_folder_unit:
            self.chk = ctk.CTkCheckBox(
                self, text="", variable=self.selected,
                width=22, height=22, corner_radius=4,
                fg_color=C["accent"], hover_color=C["accent_hover"],
                border_color=C["border"], command=self._on_check)
            self.chk.pack(side="left", padx=(16, 6))
        else:
            spacer = ctk.CTkLabel(self, text="", width=44)
            spacer.pack(side="left")

        ctk.CTkLabel(self, text=icon, font=("Segoe UI", 16), width=28).pack(side="left", padx=(0, 6))

        name_label = ctk.CTkLabel(
            self, text=display_name,
            font=("Segoe UI Semibold" if is_folder_unit else "Segoe UI", 13),
            text_color=C["accent"] if is_folder_unit else C["text"],
            anchor="w")
        name_label.pack(side="left", fill="x", expand=True)

        if size_text:
            ctk.CTkLabel(self, text=size_text, font=("Segoe UI", 11),
                         text_color=C["text2"], width=100, anchor="e").pack(side="right", padx=(4, 16))

    def _on_check(self):
        if self.on_toggle:
            self.on_toggle()


class ReceiverUI(ctk.CTkFrame):
    def __init__(self, master, switch_callback):
        super().__init__(master, fg_color=C["bg"], corner_radius=0)
        self.switch_callback = switch_callback
        self.client = HTTPClient()
        self.msg_queue = queue.Queue()
        self.file_entries = []     # raw list from server
        self.file_rows = []        # FileRow widgets
        self._build()
        self._poll_queue()

    def _build(self):
        # â”€â”€ Top bar â”€â”€
        topbar = ctk.CTkFrame(self, fg_color=C["sidebar"], corner_radius=0, height=56)
        topbar.pack(fill="x")
        topbar.pack_propagate(False)

        ctk.CTkButton(topbar, text="â†  Back",
                      command=lambda: self.switch_callback("main"),
                      fg_color="transparent", hover_color=C["hover"],
                      font=("Segoe UI", 13), width=80, anchor="w",
                      text_color=C["text2"]).pack(side="left", padx=16, pady=10)

        ctk.CTkLabel(topbar, text="ğŸ“¥  Receiver Mode",
                     font=("Segoe UI Semibold", 18),
                     text_color=C["white"]).pack(side="left", padx=8)

        # â”€â”€ Connection bar â”€â”€
        conn_card = ctk.CTkFrame(self, fg_color=C["card"], corner_radius=12,
                                  border_width=1, border_color=C["border"])
        conn_card.pack(fill="x", padx=24, pady=(16, 8))

        conn_inner = ctk.CTkFrame(conn_card, fg_color="transparent")
        conn_inner.pack(fill="x", padx=16, pady=12)

        ctk.CTkLabel(conn_inner, text="Connect to Sender",
                     font=("Segoe UI Semibold", 14),
                     text_color=C["text"]).pack(anchor="w", pady=(0, 8))

        row = ctk.CTkFrame(conn_inner, fg_color="transparent")
        row.pack(fill="x")

        ctk.CTkLabel(row, text="IP:", font=("Segoe UI", 12),
                     text_color=C["text2"]).pack(side="left")
        self.ip_var = ctk.StringVar()
        ctk.CTkEntry(row, textvariable=self.ip_var, width=160,
                     font=("Segoe UI", 12), fg_color=C["input_bg"],
                     border_color=C["border"], corner_radius=8,
                     height=36, placeholder_text="192.168.x.x").pack(side="left", padx=(6, 14))

        ctk.CTkLabel(row, text="Port:", font=("Segoe UI", 12),
                     text_color=C["text2"]).pack(side="left")
        self.port_var = ctk.StringVar(value="8000")
        ctk.CTkEntry(row, textvariable=self.port_var, width=80,
                     font=("Segoe UI", 12), fg_color=C["input_bg"],
                     border_color=C["border"], corner_radius=8,
                     height=36).pack(side="left", padx=(6, 14))

        self.connect_btn = ctk.CTkButton(
            row, text="Connect", command=self._connect,
            font=("Segoe UI Semibold", 12), fg_color=C["accent"],
            hover_color=C["accent_hover"], corner_radius=8,
            width=110, height=36)
        self.connect_btn.pack(side="left")

        # â”€â”€ Toolbar â”€â”€
        toolbar = ctk.CTkFrame(self, fg_color="transparent", height=36)
        toolbar.pack(fill="x", padx=24, pady=(10, 2))

        self.file_count_label = ctk.CTkLabel(
            toolbar, text="No files loaded",
            font=("Segoe UI", 12), text_color=C["text_dim"])
        self.file_count_label.pack(side="left")

        self.deselect_btn = ctk.CTkButton(
            toolbar, text="Deselect All", command=self._deselect_all,
            font=("Segoe UI", 11), fg_color="transparent",
            hover_color=C["hover"], text_color=C["text2"],
            width=90, height=28, corner_radius=6, state="disabled")
        self.deselect_btn.pack(side="right", padx=4)

        self.select_all_btn = ctk.CTkButton(
            toolbar, text="Select All", command=self._select_all,
            font=("Segoe UI", 11), fg_color="transparent",
            hover_color=C["hover"], text_color=C["text2"],
            width=80, height=28, corner_radius=6, state="disabled")
        self.select_all_btn.pack(side="right", padx=4)

        # â”€â”€ File browser â”€â”€
        browser_card = ctk.CTkFrame(self, fg_color=C["card"], corner_radius=12,
                                     border_width=1, border_color=C["border"])
        browser_card.pack(fill="both", expand=True, padx=24, pady=(4, 8))

        # Header row
        header = ctk.CTkFrame(browser_card, fg_color=C["sidebar"], corner_radius=0, height=36)
        header.pack(fill="x", padx=2, pady=(2, 0))
        header.pack_propagate(False)

        ctk.CTkLabel(header, text="      Name", font=("Segoe UI Semibold", 12),
                     text_color=C["text_dim"], anchor="w").pack(side="left", padx=16, fill="x", expand=True)
        ctk.CTkLabel(header, text="Size", font=("Segoe UI Semibold", 12),
                     text_color=C["text_dim"], width=100, anchor="e").pack(side="right", padx=(4, 16))

        self.file_scroll = ctk.CTkScrollableFrame(browser_card, fg_color="transparent",
                                                    corner_radius=0)
        self.file_scroll.pack(fill="both", expand=True, padx=2, pady=(0, 2))

        # Placeholder
        self.placeholder = ctk.CTkLabel(
            self.file_scroll, text="Connect to a sender to browse files",
            font=("Segoe UI", 13), text_color=C["text_dim"])
        self.placeholder.pack(pady=60)

        # â”€â”€ Bottom bar â”€â”€
        bottom = ctk.CTkFrame(self, fg_color=C["sidebar"], corner_radius=0, height=88)
        bottom.pack(fill="x", side="bottom")
        bottom.pack_propagate(False)

        # Progress section
        prog_frame = ctk.CTkFrame(bottom, fg_color="transparent")
        prog_frame.pack(fill="x", padx=24, pady=(10, 0))

        self.status_label = ctk.CTkLabel(prog_frame, text="Ready",
                                          font=("Segoe UI", 12),
                                          text_color=C["text_dim"])
        self.status_label.pack(side="left")

        self.progress_pct = ctk.CTkLabel(prog_frame, text="",
                                          font=("Segoe UI", 12),
                                          text_color=C["accent"])
        self.progress_pct.pack(side="right")

        self.progress_bar = ctk.CTkProgressBar(bottom, height=6, corner_radius=3,
                                                fg_color=C["input_bg"],
                                                progress_color=C["accent"])
        self.progress_bar.set(0)
        self.progress_bar.pack(fill="x", padx=24, pady=(8, 12))

        # Buttons - properly centered
        btn_container = ctk.CTkFrame(bottom, fg_color="transparent")
        btn_container.pack(fill="x", pady=(0, 14))
        
        btn_frame = ctk.CTkFrame(btn_container, fg_color="transparent")
        btn_frame.pack()

        self.dl_selected_btn = ctk.CTkButton(
            btn_frame, text="ğŸ“¥  Download Selected", command=self._download_selected,
            font=("Segoe UI Semibold", 13), fg_color=C["accent"],
            hover_color=C["accent_hover"], corner_radius=8,
            width=200, height=38, state="disabled")
        self.dl_selected_btn.pack(side="left", padx=10)

        self.dl_all_btn = ctk.CTkButton(
            btn_frame, text="ğŸ“¦  Download All (ZIP)", command=self._download_all,
            font=("Segoe UI Semibold", 13), fg_color="#6b46c1",
            hover_color="#7c3aed", corner_radius=8,
            width=200, height=38, state="disabled")
        self.dl_all_btn.pack(side="left", padx=10)

    # â”€â”€ Queue polling â”€â”€
    def _poll_queue(self):
        try:
            if not self.winfo_exists():
                return
            while True:
                msg = self.msg_queue.get_nowait()
                self._handle_msg(msg)
        except queue.Empty:
            pass
        except Exception:
            return
        if self.winfo_exists():
            self.after(80, self._poll_queue)

    def _handle_msg(self, msg):
        t = msg.get("type")

        if t == "list_result":
            self.connect_btn.configure(state="normal", text="Connect")
            if msg["success"]:
                self._populate_files(msg["data"])
            else:
                self.status_label.configure(text="Connection failed")
                messagebox.showerror("Error", msg["data"])

        elif t == "progress":
            cur, total = msg["current"], msg["total"]
            if total > 0:
                pct = cur / total
                self.progress_bar.set(pct)
                self.progress_pct.configure(text=f"{int(pct * 100)}%")
                self.status_label.configure(text=f"Downloading... {_human_size(cur)} / {_human_size(total)}")

        elif t == "file_progress":
            cur, total = msg["current"], msg["total"]
            self.status_label.configure(text=f"File {cur}/{total}: {msg.get('name', '')}")
            self.progress_bar.set(cur / total if total else 0)
            self.progress_pct.configure(text=f"{cur}/{total}")

        elif t == "download_result":
            self.dl_selected_btn.configure(state="normal")
            self.dl_all_btn.configure(state="normal")
            if msg["success"]:
                self.progress_bar.set(1)
                self.progress_pct.configure(text="100%")
                self.status_label.configure(text="Download complete!")
                messagebox.showinfo("Success", msg["message"])
            else:
                self.progress_bar.set(0)
                self.progress_pct.configure(text="")
                self.status_label.configure(text="Download failed")
                messagebox.showerror("Error", msg["message"])

    # â”€â”€ Connection â”€â”€
    def _connect(self):
        ip = self.ip_var.get().strip()
        port = self.port_var.get().strip()
        if not ip or not port:
            messagebox.showwarning("Input Error", "Enter both IP and Port.")
            return
        self.status_label.configure(text="Connecting...")
        self.connect_btn.configure(state="disabled", text="Connecting...")
        threading.Thread(target=self._list_thread, args=(ip, port), daemon=True).start()

    def _list_thread(self, ip, port):
        ok, data = self.client.list_files(ip, port)
        self.msg_queue.put({"type": "list_result", "success": ok, "data": data})

    # â”€â”€ File list population â”€â”€
    def _populate_files(self, entries):
        # Clear old rows
        for w in self.file_scroll.winfo_children():
            w.destroy()
        self.file_rows.clear()
        self.file_entries = entries

        if not entries:
            ctk.CTkLabel(self.file_scroll, text="No files found",
                         font=("Segoe UI", 13), text_color=C["text_dim"]).pack(pady=40)
            return

        # Sort: folders first, then files, both alphabetically
        folders = sorted([e for e in entries if e["type"] == "folder"],
                         key=lambda x: x["path"])
        files = sorted([e for e in entries if e["type"] == "file"],
                       key=lambda x: x["path"])

        # Build tree-like display â†’ group files under their folders
        displayed = set()
        row_idx = 0

        # First show folders as section headers, then their files
        folder_paths = {f["path"] for f in folders}

        # Determine nesting depth
        def depth_of(path):
            return path.count("/")

        # Show all folders
        for folder in folders:
            fr = FileRow(self.file_scroll, folder, depth=depth_of(folder["path"]),
                         on_toggle=self._update_selection_count)
            bg = C["card"] if row_idx % 2 == 0 else C["row_alt"]
            fr.configure(fg_color=bg)
            fr.pack(fill="x")
            self.file_rows.append(fr)
            row_idx += 1

            # Show files in this folder
            for f in files:
                parent = os.path.dirname(f["path"])
                if parent.replace("\\", "/") == folder["path"]:
                    fr2 = FileRow(self.file_scroll, f,
                                  depth=depth_of(f["path"]),
                                  on_toggle=self._update_selection_count)
                    bg = C["card"] if row_idx % 2 == 0 else C["row_alt"]
                    fr2.configure(fg_color=bg)
                    fr2.pack(fill="x")
                    self.file_rows.append(fr2)
                    displayed.add(f["path"])
                    row_idx += 1

        # Show root-level files (no parent folder)
        for f in files:
            if f["path"] not in displayed:
                fr = FileRow(self.file_scroll, f, depth=0,
                             on_toggle=self._update_selection_count)
                bg = C["card"] if row_idx % 2 == 0 else C["row_alt"]
                fr.configure(fg_color=bg)
                fr.pack(fill="x")
                self.file_rows.append(fr)
                row_idx += 1

        total_files = len(files)
        total_size = sum(f["size"] for f in files)
        self.file_count_label.configure(
            text=f"{total_files} file(s)  â€¢  {len(folders)} folder(s)  â€¢  {_human_size(total_size)}")

        self.dl_selected_btn.configure(state="normal")
        self.dl_all_btn.configure(state="normal")
        self.select_all_btn.configure(state="normal")
        self.deselect_btn.configure(state="normal")
        self.status_label.configure(text=f"Connected â€” {total_files} files found")

    # â”€â”€ Selection helpers â”€â”€
    def _get_selected_items(self):
        # Return both individual files and folder units for download
        selected = []
        for r in self.file_rows:
            if r.selected.get():
                if r.entry.get("is_folder_unit"):
                    # For folder units, include all files in that folder
                    folder_name = r.entry["path"]
                    folder_files = [e for e in self.file_entries 
                                  if e["type"] == "file" and e["path"].startswith(folder_name + "/")]
                    selected.extend(folder_files)
                elif r.entry["type"] == "file":
                    selected.append(r.entry)
        return selected

    def _select_all(self):
        for r in self.file_rows:
            if r.entry["type"] == "file" or r.entry.get("is_folder_unit"):
                r.selected.set(True)
        self._update_selection_count()

    def _deselect_all(self):
        for r in self.file_rows:
            if r.entry["type"] == "file" or r.entry.get("is_folder_unit"):
                r.selected.set(False)
        self._update_selection_count()

    def _update_selection_count(self):
        sel = self._get_selected_items()
        if sel:
            total = sum(f["size"] for f in sel)
            self.status_label.configure(
                text=f"{len(sel)} file(s) selected  â€¢  {_human_size(total)}")
        else:
            folder_count = sum(1 for r in self.file_rows if r.entry.get("is_folder_unit"))
            self.status_label.configure(text=f"Ready to download â€” {folder_count} folders available")

    # â”€â”€ Downloads â”€â”€
    def _download_selected(self):
        selected = self._get_selected_items()
        if not selected:
            messagebox.showwarning("No Selection", "Select at least one item to download.")
            return

        save_dir = filedialog.askdirectory(title="Choose Download Location")
        if not save_dir:
            return

        ip = self.ip_var.get().strip()
        port = self.port_var.get().strip()

        self.dl_selected_btn.configure(state="disabled")
        self.dl_all_btn.configure(state="disabled")
        self.progress_bar.set(0)
        self.progress_pct.configure(text="0%")

        threading.Thread(target=self._batch_download_thread,
                         args=(ip, port, selected, save_dir), daemon=True).start()

    def _batch_download_thread(self, ip, port, files, save_dir):
        total = len(files)
        ok_count = 0

        for i, entry in enumerate(files):
            rel_path = entry["path"]
            save_path = os.path.join(save_dir, rel_path)

            self.msg_queue.put({
                "type": "file_progress", "current": i + 1,
                "total": total, "name": entry["name"]})

            def progress_cb(cur, tot):
                self.msg_queue.put({"type": "progress", "current": cur, "total": tot})

            ok, _ = self.client.download_file(ip, port, rel_path, save_path, progress_cb)
            if ok:
                ok_count += 1

        self.msg_queue.put({
            "type": "download_result", "success": ok_count > 0,
            "message": f"Downloaded {ok_count}/{total} files to:\n{save_dir}"})

    def _download_all(self):
        save_path = filedialog.asksaveasfilename(
            defaultextension=".zip",
            filetypes=[("Zip Archive", "*.zip")],
            initialfile="shared_files.zip",
            title="Save ZIP As")
        if not save_path:
            return

        ip = self.ip_var.get().strip()
        port = self.port_var.get().strip()

        self.dl_selected_btn.configure(state="disabled")
        self.dl_all_btn.configure(state="disabled")
        self.progress_bar.set(0)
        self.progress_pct.configure(text="0%")
        self.status_label.configure(text="Downloading ZIP...")

        threading.Thread(target=self._zip_download_thread,
                         args=(ip, port, save_path), daemon=True).start()

    def _zip_download_thread(self, ip, port, save_path):
        def progress_cb(cur, tot):
            self.msg_queue.put({"type": "progress", "current": cur, "total": tot})

        ok, msg = self.client.download_all(ip, port, save_path, progress_cb)
        self.msg_queue.put({"type": "download_result", "success": ok, "message": msg})
